name: ðŸ“Š System Monitoring & Health Checks

on:
  schedule:
    # Check every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch:
    inputs:
      detailed_check:
        description: 'Run detailed system diagnostics'
        required: false
        default: 'false'
        type: boolean
      notify_on_success:
        description: 'Send notification even on success'
        required: false
        default: 'false'
        type: boolean

env:
  NODE_VERSION: '20'
  HEALTH_CHECK_URL: https://claude-marketplace.github.io/aggregator/api/health
  STATUS_CHECK_URL: https://claude-marketplace.github.io/aggregator/api/status
  WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
  SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}

jobs:
  health-check:
    name: ðŸ” Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      status: ${{ steps.check.outputs.status }}
      response_time: ${{ steps.check.outputs.response_time }}
      message: ${{ steps.check.outputs.message }}

    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¦ Install Dependencies
        run: npm ci --prefer-offline --no-audit

      - name: ðŸ” Basic Health Check
        id: check
        run: |
          echo "Checking system health at $(date)"

          # Measure response time
          start_time=$(date +%s%N)

          # Perform health check
          response=$(curl -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total}" \
            -H "Cache-Control: no-cache" \
            -H "User-Agent: GitHub-Monitor/1.0" \
            "${{ env.HEALTH_CHECK_URL }}" || echo "HTTPSTATUS:000;TIME:0")

          end_time=$(date +%s%N)

          # Parse response
          http_code=$(echo "$response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
          response_time=$(echo "$response" | grep -o "TIME:[0-9.]*" | cut -d: -f2)
          response_body=$(echo "$response" | sed 's/HTTPSTATUS:[0-9]*;TIME:[0-9.]*//')

          echo "HTTP Status: $http_code"
          echo "Response Time: ${response_time}s"

          # Parse JSON response if available
          if echo "$response_body" | jq empty 2>/dev/null; then
            health_status=$(echo "$response_body" | jq -r '.status // "unknown"')
            uptime=$(echo "$response_body" | jq -r '.uptime // 0')
            version=$(echo "$response_body" | jq -r '.version // "unknown"')

            echo "Health Status: $health_status"
            echo "Uptime: ${uptime}s"
            echo "Version: $version"

            # Check individual system components
            data_files_ok=$(echo "$response_body" | jq -r '.checks.dataFiles // false')
            github_api_ok=$(echo "$response_body" | jq -r '.checks.githubApi // false')
            build_ok=$(echo "$response_body" | jq -r '.checks.buildStatus // false')
            memory_ok=$(echo "$response_body" | jq -r '.checks.memoryUsage // false')

            echo "Data Files: $data_files_ok"
            echo "GitHub API: $github_api_ok"
            echo "Build Status: $build_ok"
            echo "Memory Usage: $memory_ok"

            # Determine overall status
            if [[ "$http_code" == "200" && "$health_status" == "healthy" && "$data_files_ok" == "true" && "$github_api_ok" == "true" && "$build_ok" == "true" && "$memory_ok" == "true" ]]; then
              echo "status=healthy" >> $GITHUB_OUTPUT
              echo "message=âœ… All systems operational - Response time: ${response_time}s" >> $GITHUB_OUTPUT
            else
              echo "status=unhealthy" >> $GITHUB_OUTPUT
              echo "message=âŒ System issues detected - HTTP: $http_code, Status: $health_status, Response time: ${response_time}s" >> $GITHUB_OUTPUT
            fi
          else
            echo "status=unhealthy" >> $GITHUB_OUTPUT
            echo "message=âŒ Invalid response from health endpoint - HTTP: $http_code, Response time: ${response_time}s" >> $GITHUB_OUTPUT
          fi

          echo "response_time=$response_time" >> $GITHUB_OUTPUT

      - name: ðŸ“Š Detailed System Status
        id: detailed
        if: github.event.inputs.detailed_check == 'true'
        run: |
          echo "Fetching detailed system status..."

          response=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -H "Cache-Control: no-cache" \
            -H "User-Agent: GitHub-Monitor/1.0" \
            "${{ env.STATUS_CHECK_URL }}" || echo "HTTPSTATUS:000")

          http_code=$(echo "$response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
          response_body=$(echo "$response" | sed 's/HTTPSTATUS:[0-9]*//')

          if echo "$response_body" | jq empty 2>/dev/null; then
            overall_status=$(echo "$response_body" | jq -r '.status // "unknown"')
            data_status=$(echo "$response_body" | jq -r '.systems.data.status // "unknown"')
            github_status=$(echo "$response_body" | jq -r '.systems.github.status // "unknown"')
            build_status=$(echo "$response_body" | jq -r '.systems.build.status // "unknown"')
            perf_status=$(echo "$response_body" | jq -r '.systems.performance.status // "unknown"')

            echo "Overall Status: $overall_status"
            echo "Data System: $data_status"
            echo "GitHub API: $github_status"
            echo "Build System: $build_status"
            echo "Performance: $perf_status"

            # Save detailed report
            echo "$response_body" | jq '.' > detailed-status.json

            # Output summary for notification
            {
              "overall": "$overall_status",
              "data": "$data_status",
              "github": "$github_status",
              "build": "$build_status",
              "performance": "$perf_status",
              "metrics": $(echo "$response_body" | jq '.metrics')
            } > status-summary.json
          else
            echo "Failed to get detailed status"
            echo '{"overall":"error","data":"error","github":"error","build":"error","performance":"error"}' > status-summary.json
          fi

      - name: ðŸ“¤ Upload Status Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: health-report-${{ github.run_number }}
          path: |
            detailed-status.json
            status-summary.json
          retention-days: 7

  notify-team:
    name: ðŸ“¢ Notify Team
    needs: health-check
    runs-on: ubuntu-latest
    if: failure() || needs.health-check.outputs.status == 'unhealthy' || github.event.inputs.notify_on_success == 'true'

    steps:
      - name: ðŸ“¥ Download Status Report
        if: always()
        uses: actions/download-artifact@v4
        with:
          name: health-report-${{ github.run_number }}
          path: ./reports

      - name: ðŸ“ Prepare Notification
        id: prepare
        run: |
          status="${{ needs.health-check.outputs.status }}"
          response_time="${{ needs.health-check.outputs.response_time }}"
          message="${{ needs.health-check.outputs.message }}"

          # Determine emoji and color
          if [[ "$status" == "healthy" ]]; then
            emoji="âœ…"
            color="good"
            title="System Health Check - All Systems Operational"
          else
            emoji="âŒ"
            color="danger"
            title="ðŸš¨ System Health Check - Issues Detected"
          fi

          # Create Slack message
          cat > slack-message.json << EOF
          {
            "attachments": [
              {
                "color": "$color",
                "title": "$title",
                "title_link": "https://github.com/claude-marketplace/aggregator/actions/runs/${{ github.run_id }}",
                "text": "$message",
                "fields": [
                  {
                    "title": "Status",
                    "value": "$status",
                    "short": true
                  },
                  {
                    "title": "Response Time",
                    "value": "${response_time}s",
                    "short": true
                  },
                  {
                    "title": "Checked At",
                    "value": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
                    "short": true
                  },
                  {
                    "title": "Environment",
                    "value": "Production",
                    "short": true
                  }
                ],
                "footer": "Claude Marketplace Aggregator",
                "ts": $(date +%s)
              }
            ]
          }
          EOF

          # Create webhook message
          cat > webhook-message.json << EOF
          {
            "text": "$emoji $message",
            "attachments": [
              {
                "fields": [
                  {
                    "title": "Details",
                    "value": "<https://github.com/claude-marketplace/aggregator/actions/runs/${{ github.run_id }}|View Run>",
                    "short": false
                  }
                ]
              }
            ]
          }
          EOF

      - name: ðŸ“¤ Send Slack Notification
        if: env.SLACK_WEBHOOK != ''
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data @slack-message.json \
            "${{ env.SLACK_WEBHOOK }}"

      - name: ðŸ“¤ Send Webhook Notification
        if: env.WEBHOOK_URL != ''
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data @webhook-message.json \
            "${{ env.WEBHOOK_URL }}"

      - name: ðŸ¦ Create Issue for Failures
        if: failure() && needs.health-check.outputs.status == 'unhealthy'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `Health Check Failure - ${new Date().toISOString()}`;
            const body = `
            ## ðŸš¨ Health Check Failure

            **Time**: ${new Date().toISOString()}
            **Status**: ${{ needs.health-check.outputs.status }}
            **Response Time**: ${{ needs.health-check.outputs.response_time }}s
            **Message**: ${{ needs.health-check.outputs.message }}

            ### Actions Required
            - [ ] Check the [workflow run](https://github.com/claude-marketplace/aggregator/actions/runs/${{ github.run_id }})
            - [ ] Investigate system logs
            - [ ] Verify GitHub API access
            - [ ] Check data freshness
            - [ ] Update issue status when resolved


            `;

            try {
              const response = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['bug', 'health-check', 'urgent']
              });

              console.log(`Created issue #${response.data.number}`);
            } catch (error) {
              console.error('Failed to create issue:', error);
            }

  performance-monitoring:
    name: ðŸ“ˆ Performance Monitoring
    runs-on: ubuntu-latest
    if: github.event.inputs.detailed_check == 'true'

    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¦ Install Dependencies
        run: npm ci --prefer-offline --no-audit

      - name: ðŸ“Š Run Performance Tests
        run: |
          echo "Running performance tests..."

          # Test API response times
          endpoints=(
            "${{ env.HEALTH_CHECK_URL }}"
            "${{ env.STATUS_CHECK_URL }}"
            "https://claude-marketplace.github.io/aggregator/data/index.json"
          )

          for endpoint in "${endpoints[@]}"; do
            echo "Testing endpoint: $endpoint"

            # Run multiple tests and calculate average
            total_time=0
            for i in {1..5}; do
              response=$(curl -s -o /dev/null -w "%{time_total}" "$endpoint")
              total_time=$(echo "$total_time + $response" | bc -l)
            done

            avg_time=$(echo "scale=3; $total_time / 5" | bc -l)
            echo "Average response time for $endpoint: ${avg_time}s"

            # Add to performance report
            echo "{\"endpoint\": \"$endpoint\", \"average_response_time\": $avg_time, \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}" >> performance-report.json

            # Check if response time is acceptable
            if (( $(echo "$avg_time > 2.0" | bc -l) )); then
              echo "âš ï¸ Slow response time detected: ${avg_time}s"
            fi
          done

          # Test website load time (if Lighthouse is available)
          if command -v lighthouse >/dev/null 2>&1; then
            echo "Running Lighthouse performance test..."
            lighthouse "https://claude-marketplace.github.io/aggregator" \
              --output=json \
              --output-path=lighthouse-report.json \
              --chrome-flags="--headless" \
              --quiet
          fi

      - name: ðŸ“¤ Upload Performance Report
        uses: actions/upload-artifact@v4
        with:
          name: performance-report-${{ github.run_number }}
          path: |
            performance-report.json
            lighthouse-report.json
          retention-days: 7

  cleanup:
    name: ðŸ§¹ Cleanup Old Reports
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: ðŸ—‘ï¸ Clean Up Old Artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
            });

            // Keep only the last 10 reports
            const healthReports = artifacts.data.artifacts
              .filter(a => a.name.startsWith('health-report-'))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
              .slice(10);

            for (const artifact of healthReports) {
              await github.rest.actions.deleteArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: artifact.id,
              });
              console.log(`Deleted old artifact: ${artifact.name}`);
            }